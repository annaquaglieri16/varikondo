---
title: "Introduction to of varikondo"
author: "Anna Quaglieri"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      collapse = TRUE,
                      comment = "#>")
```


# Setup 

The `varikondo` R package comprises several helper and import functions that can be used to convert output from any of the callers mentioned above to a standardised format.

```{r eval=FALSE}
library(devtools)
devtools::install_github("annaquaglieri16/varikondo")
```


```{r eval=TRUE}
library(varikondo)
```

```{r}
ls("package:varikondo")
```

# Parsing: from `VCF` to tody data frame

The function `parse_vcf_output()` allows to convert a `VCF` file generated by three different callers `GATK3 MuTect2`, `VarDict` or `VarScan`, to a data frame with standardised fields. This is because different callers annotate the `INFO` field in the `VCF` ouput in different ways, using different names for read depth, variant allele frequency etc... The output from `parse_vcf_output()` can then be used as input `variants` for `import_any()` to combine variants and clinical information and fill in missing variants at specific time points. If the variants in the `VCF` file were also annotated with the Variant Effect Predictor (VEP) [@McLaren2016-lv], the one can set `vep = TRUE` to parse the extra fields. 

It is to be noted that `VEP` might annotate the same variant multiple times, depending on whether a variants falls on several transcripts. VEP pastes together different annotations on the same line. `parse_vcf_output` will reshape the input variants and return it in a long format by stacking all the annotations one underneath each other. This has the potential of largely increasing the size of the ouput file and it is suggested to subset variants based on genes of interest, if the input `VCF` file is too large.   

The `parse_vcf_output` functions is built on top of the [`VariantAnnotation`](https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html) Bioconductor package [@Obenchain2014-cd] to quickly read large `VCF` files into `R` and extract fields.

Below is a graphic overview about how to parse a list of `VCF` files for one sample. The same can be extended for any patient. 

```{r echo=FALSE,eval=FALSE, fig.cap="Overview of function to import and parce VCF files."}
knitr::include_graphics("../figures/import-any.png")
```


The example `VCF` files below were annotated with VEP. Also `germline_varscan.vcf` and `germline_vardict.vcf` are available as example. 

```{r include=TRUE,echo=TRUE}
annot_vcf_mutect <- system.file("extdata", "germline_mutect.vcf", package = "varikondo")
annot_vcf_mutect
```

`VCF` files from `VarDict` and `VarScan` can be parsed by specifying `caller = "vardict"` or `caller = "varscan"`.

```{r include=FALSE,echo=TRUE}
parsed_vcf_mutect <- varikondo::parse_vcf_output(annot_vcf_mutect, caller = "mutect",sample_name = "Sample1",vep = TRUE)
```

```{r parsed-vcf-mut}
knitr::kable(parsed_vcf_mutect[1:10,],caption = "Parsed MuTect2 output, from VCF to data frame.")
```

You can find in [Standardise VCFs output across callers](#st-variants) more details about the exact fields that I extract from a caller's `VCF` file to populate the standardised fields given in ouput.

# Import functions

In general, the import functions can take in input variants called by a caller as well as clinical information for all the patients in the cohort under investigation. Every input function requires a `patientID` to be provided and a set of `studyGenes` to restrict the analysis on. `studygenes` are expected to be a character vector of NCBI gene `Symbols`. This means that variants need to be annotated with the gene they belong to before `varikondo` can be used. The clinical data at every time point is needed because if a variant is not detected at one time point for a patient, then the input variants will be extended to include all time points initially available for that patient but with default values for missing fields (e.g. VAF = 0). This is useful for visualisation purposes where one needs to track the development of mutation over time.

## Import, combine and standardise `superFreq` outputs


```{r eval=TRUE}
knitr::include_graphics("../figures/import-superfreq.png")
```

The `import_goi_superfreq()` function was specifically build to extract all the outputs produced by the caller which would be otherwise stored in nested lists within each patient's `Rdata` file or in `.csv` file if sometic variants. `superFreq` produces output from sometic SNVs, CNVs and clone tracking. A `superFreq` run for a cohort of patients (view [instructions](https://github.com/ChristofferFlensburg/superFreq)) will create and `R` folder with results for each patient, each stored within a folder. `import_goi_supefreq` will look into this folder to extract all the results. `import_goi_supefreq` also needs a path to the cohort metadata file in order to match the ouput from each sample with its patient name and time points.  

```{r eval=FALSE}
import_sf <- import_goi_supefreq(superFreq_R_path = superFreq_R_path,
                                 superFreq_meta_path = superFreq_meta_path,
                                 studyGenes,
                                 patientID = "D1",
                                 ref_genome = "hg38",
                                 VAFcut = 0.15)
```





# Standardise VCFs output across callers {#st-variants}

Following, is the list of fields which are given as output after parsing a VCF file with `parse_vcf_output()`. Here is a description of what information was extracted for every caller to populate each standardised fields:

* *Location*: `CHR_POS` where `CHR` and `POS` are standard `VCF` fields for every caller.
* *caller*: the caller passed to the `caller` argument.
* *chrom*: field `CHROM` in the `VCF` file.
* *pos*: field `POS` in the `VCF` file.
* *ref*: field `REF` in the `VCF` file.
* *alt*: field `ALT` in the `VCF` file.
* *qual*: This field is not reported consistently from the VCF output of the three callers but I made sure that its meaning is consistent and that it represents the average base quality at that position. Below is a description of how it is extracted from each caller.
    - In `MuTect2` the `QSS` field in the `FORMAT` fields reports the sum of the base qualities for the reference and alternative alleles separated by a comma. We used the reference and alternative depths at each position to compute the overall average base quality at that position. This quantity will populate the final `qual` field. 
    - In `VarScan` this field is the average of the `RBQ` and `ABQ` fields from the `FORMAT` fields. They are defined respectively as the average quality of reference and alternative supporting bases in the header of the `VCF` file.
    - In `VarDict` there are two `QUAL` fields, one is the standard 6th field of a `VCF` file and the other one is reported in the `INFO` fields. We will use the latter to populate the `qual` field in our analysis since it is the one defined as the average base quality at a variant position in the header of the `VCF`. `VarDict` uses a threshold of `QUAL >= 25` to report a variant. 

* *filter*:  standard field `FILTER` in the `VCF` file. Each caller populates this field in different ways depending on the characteristics of the algorithm. In general, the entries for this field can be either `PASS` if that mutation passes all the filters defined by a caller or a description of the reason for filtering. The possible descriptions and their meaning can be found in the header of the VCF file generated by the caller.

* *genotype*: standard `GT` field in the `FORMAT` fields of the `VCF` file.

* *tot_depth*: total read depth at each position as estimated by the caller. This information can be reported differently by each caller. `VarDict` and `VarScan`  record it in the `DP` field while `MuTect2` records the reference and alternative depth in the `AD` columns and their sum was used to define the `total_depth`.

* *VAF*: variant allele frequency for the variants recorded at that position. `VarScan` records it in the `FREQ` field while `MuTect` and `VarDict` in the `AF` field. 

* *ADJVAF_ADJ_indels*: field `ADJAF` only reported by `VarDict` and it represents the adjusted variant allele frequency for indels due to local realignment.

* *ref_depth*, *alt_depth*, *ref_forw*, *ref_rev*, *alt_forw* and *alt_rev*: these fields represent the breakdown of supporting reference/alternative and forward/reverse reads at each location. Below I described what fields I used from every caller to extract these values. The fields are listed in order:
    - `MuTect2`: *ref_depth* and *alt_depth* are the comma separated values reported in the field `AD`; *ref_forw*, *ref_rev*, *alt_forw* and *alt_rev* are respectively the `MuTect2` fields `REF_F1R2`, `REF_F2R1`, `ALT_F1R2` and `ALT_F2R1`. 
    - `VarScan2`: in order the features listed above are extracted from the the fields `RD`, `AD`, `RDF`, `RDR`, `ADF` and `ADR`.
    - `VarDict`: *ref_depth* and *alt_depth* are the fields `REF` and `ALT` in the VCF file; the field `REFBIAS` contains comma separated values representing  *ref_forw* and *ref_rev* and `VARBIAS` contains comma separated values representing *alt_forw* and *alt_rev*.
  
If the `VCF` file was also annotated using the Variant Effect Predictor (VEP) [@McLaren2016-lv]  
All the other fields are exactly as generated by `VEP`: `Allele`, `Consequence`, `IMPACT`, `SYMBOL`, `Gene`, `Feature_type`, `Feature`, `BIOTYPE`, `EXON`, `INTRON`, `HGVSc`,  `HGVSp`, `cDNA_position`, `CDS_position`, `Protein_position`   `Amino_acids`, `Codons`, `Existing_variation` `DISTANCE`, `STRAND`, `FLAGS`, `VARIANT_CLASS`, `SYMBOL_SOURCE`, `HGNC_ID`, `CANONICAL`, `TSL`, `APPRIS`, `CCDS`, `ENSP`, `SWISSPROT`, `TREMBL`, `UNIPARC`, `GENE_PHENO`, `SIFT`, `PolyPhen`, `DOMAINS`, `AF`, `AFR_AF`, `AMR_AF`, `EAS_AF`, `EUR_AF`, `SAS_AF`, `AA_AF`,  `EA_AF`, `ExAC_AF`, `ExAC_Adj_AF`, `ExAC_AFR_AF`, `ExAC_AMR_AF`, `ExAC_EAS_AF`, `ExAC_FIN_AF`, `ExAC_NFE_AF`, `ExAC_OTH_AF`,  `ExAC_SAS_AF`, `MAX_AF`, `MAX_AF_POPS`, `CLIN_SIG`, `SOMATIC`, `PHENO`, `PUBMED`,`MOTIF_NAME`, `MOTIF_POS`, `HIGH_INF_POS`, `MOTIF_SCORE_CHANGE` `SampleName`, `IMPACT_rank`. 
Visit the `VEP` page to find more information https://asia.ensembl.org/info/docs/tools/vep/index.html. 


# Aknowledgements

