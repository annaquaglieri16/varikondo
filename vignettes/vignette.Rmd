---
title: "Introduction to varikondo"
author: "Anna Quaglieri"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
    toc_float: true
bibliography: ../biblio.bib
vignette: >
  %\VignetteIndexEntry{Introduction to varikondo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      collapse = TRUE,
                      comment = "#>")
```


# Setup 

The `varikondo` R package comprises several helper and import functions that can be used to convert output from any of the callers mentioned above to a standardised format.

First, let's load the package. 

```{r eval=FALSE}
library(devtools)
devtools::install_github("annaquaglieri16/varikondo")
```


```{r eval=TRUE}
library(varikondo)
utils::packageVersion("varikondo")
```

```{r}
ls("package:varikondo")
```

```{r}
library(dplyr)
library(ggplot2)
library(cowplot)
```

# Import and parse a single `VCF` 

The function `parse_vcf_output()` allows to convert a `VCF` file generated by one of four callers [`GATK3 MuTect2`](https://software.broadinstitute.org/gatk/documentation/tooldocs/3.8-0/org_broadinstitute_gatk_tools_walkers_cancer_m2_MuTect2.php), [`VarDict`](https://github.com/AstraZeneca-NGS/VarDict), [`VarScan`](http://varscan.sourceforge.net/), and [`FreeBayes`](https://github.com/ekg/freebayes) to a data frame with standardised fields. This is because different callers annotate the `INFO` field in the `VCF` ouput in different ways, using different names for read depth, variant allele frequency etc... The output from `parse_vcf_output()` can then be used as input for `import_any()` to combine variants and clinical information for different samples within the same patients and to fill in missing variants at specific time points. If the variants in the `VCF` file are also annotated with the Variant Effect Predictor (VEP) [@McLaren2016-lv], `vep = TRUE` will parse the extra fields. 

## Import only specific ranges of the VCF file

VEP might annotate the same variant multiple times, depending on whether a variants falls on several transcripts. VEP pastes together different annotations on the same line. `parse_vcf_output()` will reshape the input variants and return it in a long format by stacking all the annotations one underneath each other. This has the potential to largely increase the size of the ouput file. To overcome this problem it is possible to read in R only restricted genomic regions at one time by specifying a `GRanges()` object in `parse_vcf_output(param = VariantAnnotation::ScanVcfParam())`. The `param` argument is directly passed to `VariantAnnotation::readVcf()` within `parse_vcf_output()`.



The example `VCF` files below were annotated with VEP. Also `chr20_varscan.vcf.gz`, `chr20_vardict.vcf.gz` are available as example. 

```{r include=TRUE,echo=TRUE}
annot_vcf_mutect <- system.file("extdata", "chr20_mutect.vcf.gz", package = "varikondo")
annot_vcf_mutect
```

`VCF` files from `VarDict`, `VarScan`, and `freebayes` can be parsed by specifying `caller = "vardict"`, `caller = "varscan"`, `caller = "freebayes"`.

```{r include=TRUE,echo=TRUE,eval=TRUE}
parsed_vcf_mutect <- varikondo::parse_vcf_output(vcf_path = annot_vcf_mutect, 
                                                 caller = "mutect",
                                                 sample_name = "Sample1",
                                                 vep = TRUE)
```

```{r parsed-vcf-mut}
knitr::kable(parsed_vcf_mutect[1:10,],caption = "Parsed MuTect2 output, from VCF to data frame.")
```



# `import_any`: joint filtering and improve visualisation over time

This section is more focused on specific tasks that involves preparing the data for plotting the changes of variants over time (usually using the VAF). This was a recurring task within the sort of clinical trial structures that led to the development of `varikondo`. This includes a not too large cohort of patients (`PID`) followed up over `Time`, usually before and after treatment, and for which some clinical information, like % tumour content (e.g. `Blast`) are collected over the course of the treatment. Patients usually have an overall `Outcome` reported, depending on whether they respond to treatment (e.g. Responders, Relapse, Refractory). An more detailed example is described in [`Example: variant calling in RNA-Seq`](https://annaquaglieri16.github.io/varikondo/articles/rna-seq-pipe.html). 

`parse_vcf_ouput()` imports one VCF file for one patient at a time. To analyse variants over time across multiple samples (within a patient or cohort-wise), one needs to filter and combine multiple variants files to create a combined dataset to summarise or explore with the R Shiny app https://shiny.wehi.edu.au/quaglieri.a/shiny-clone/.

`import_any()` helps with this. `import_any()` takes in input the combined data frame of variants imported with `parse_vcf_output()` and bounded together with functions like `rbind()` or `bind_rows()`; a `patientID`; a set of `studyGenes` if available; and some quality threshold to use for filtering. The output will be a *filtered* and *filled* data frame. 

* *Filtered*. Similarly to `import_goi_superfreq()`, only variants which passes the defined thresholds at one time point within a patient are kept. 

* *Filled*. If a variant is called at one time point but not found at others, we impute `0` default values for VAF, alt_depth and ref_depth. We added this last step to allow that all patient's time points available in the `clinicalData` (metadata) are represented for every variant. This allows a complete visual assessment of a variant over time. If this is not of interest to the user, variants with `VAF == 0` can be filtered out. 

Below is an illustrative example with sample data, adapted from the type of clinical trials that we usually work on.

```{r example-variants}
sample_variants <- example_variants
knitr::kable(example_variants)
```

```{r example-metadata}
sample_metadata <- example_metadata
knitr::kable(example_metadata)
```

`import_clinical()` was developed with the mere function to reshape clinical data, like % blast content ( = tumour content), into the same format as we store variants information. Thus should make it easier to be combined and plotted together with the VAF over time.

This can be useful to compare patient's clinical assessment with the cancer molecular respinde to treatment. For example, there can be cases where even though the patient does not seem to respond to treatment (tumour content does not drop), some cancer variants (clones) do individually respond. 

```{r import-any-patient1,eval=TRUE,warning=FALSE,message=FALSE}
combine_and_fill <- varikondo::import_any(variants = sample_variants,
                               patientID = "P1",
                              # studyGenes = c("Gene1","Gene2","Gene3"),
                               clinicalData = sample_metadata,
                               min_vaf = 0.05,
                               min_alt = 2)

knitr::kable(combine_and_fill,caption = "Output from import_any() for patient P1 in example_variants.")
```


```{r import-clinical-patient1,eval=TRUE,warning=FALSE,message=FALSE}
import_blast <- varikondo::import_clinical(clinicalData = sample_metadata,
                                patientID = "P1",
                                extract_column = "Blast") 
knitr::kable(import_blast,caption = "Output from import_clinical() for patient P1 in example_metadata.")
```


```{r plot-patient1,eval=TRUE,warning=FALSE,message=FALSE}
variants <- example_variants %>% 
  bind_rows(import_blast)

p1 = variants %>%
  filter(PID %in% "P1") %>%
 ggplot(aes(x = Time, y = VAF,colour = mutation_det,group = mutation_key)) +
  geom_point() + 
  geom_line() + 
  theme_bw() + 
  theme(legend.position = "bottom") +
  ggtitle("P1 - before import_any()")


combine_and_fill <- combine_and_fill %>% 
  bind_rows(import_blast)

p2 = ggplot(combine_and_fill,aes(x = Time, y = VAF,
                               colour=mutation_det,group=mutation_key)) +
  geom_point() + 
  geom_line() + 
  theme_bw()+ 
  theme(legend.position = "bottom") +
  ggtitle("P1 - after import_any()")

legend = get_legend(p1)

sec1 <- plot_grid(p1 + theme(legend.position = "none"),
          p2 + theme(legend.position = "none"))
plot_grid(sec1,
          legend,nrow=2,rel_heights = c(4,1))
```


# Import standardised `superFreq` output

`import_goi_superfreq()` was built to import the output produced by [`superFreq`](https://github.com/ChristofferFlensburg/superFreq), normally stored in nested lists within each patient's `Rdata` file or in `.csv` files. `superFreq` is used to perform clonal tracking of cancer genomes over time and therefore produces temporal output for somatic SNVs, short INDELs, CNVs and clones. A `superFreq` run (see [instructions](https://github.com/ChristofferFlensburg/superFreq)) will create and `R` folder with results stored in separate folder by patient. `import_goi_supefreq(superFreq_R_path, patientID = "P1)` will look into this folder to extract all the results for patient `P1`. 

Usually, collaborators might be interested in summarising a particular subset of genes of interest which can be passed to `import_goi_supefreq()` as a character vector in `studyGenes`. If no `studyGenes` are provided, variants on all genes are returned. `ref_genome` is necessary since `superFreq` stores variants using a different system of genomic coordinate which needs to be converted back to cDNA locations. Other variant threshold (`min_vaf` and `min_alt`) can be used to filter variants. Within a patients, only variants which pass those thresholds at any time point will be kept. 

```{r eval=FALSE}
import_sf <- varikondo::import_goi_superfreq(superFreq_R_path = superFreq_R_path,
   superFreq_meta_path = superFreq_meta_path,
  patientID = patientID,
  studyGenes = "KIT"
  ref_genome = "hg38",
  min_vaf = 0.05,
  min_alt = 3)
```


# How we store different types of variants in output

We define genetic lesions (SNVs, INDELs, CNAs) based on their `chrom`, `pos`, `SYMBOL`, `mutation_key`, `mutation_det`, `ref`, `alt` defined below. Different genetic lesions can have slightly different definitions of these features. `superFreq` reports SNVs, short INDELs, CNAs and clones. Below are examples on how the fields above are defined for each genetic lesion. 

## Single Nucleotide Variants (SNVs) and short INDELs reported by superFreq
  
  - `chrom`: chromosome;
  - `pos`: position of point mutation in base pairs, with reference to a genome build;
  - `SYMBOL`: `NCBI` gene symbol where the `SNV` occurs;
  - `ref`: reference allele; 
  - `alt`: alternative allele; 
  - `mutation_key`: unique key for the mutation usually defined as `SYMBOL-pos-ref-alt`. This is needed to summarise and look for the same mutation across different samples. 
  - `mutation_det`: details of the mutation usually defined as `SYMBOL Any annotation`. This can be used to annotate plots with features of a variant. Since `import_goi_superfreq()` only imports output from `superFreq`, the annotation used to populate the `mutation_det` field for `SNVs` is the annotation provided by a variant annotation tool, like [`VEP`](https://asia.ensembl.org/info/docs/tools/vep/index.html) or [`VariantAnnotation`](https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html. However, `mutation_det` can be updated at will to change plot labeling. 


```{r echo = FALSE}
snvs <- data.frame(PID = "P1",
                   chrom = "chr1", 
                   pos = 4573828,
                   SYMBOL = "KIT",
                   ref = "A",
                   alt = "G",
                   mutation_key = "KIT-4573828-A-G",
                   Consequence = "nonsynonimous",
                   mutation_det = "KIT nonsynonimous",
                   variant_type=c("SNV"))
knitr::kable(snvs)
```


## Copy Number Alterations (CNAs)

A CNA involves deletions or amplifications of genomic regions of different sizes. In this pipeline we use `superFreq` to call genomic alterations but the ouput could be adapted for other callers. `superFreq` reports a CNA specifying the `chrom` where the alteration occurs; the widths of the region involved (150Bbp in the example below); and the alteration type. For example, if `AB` represents the normal genotype, then `150Mbp A ` is a 150Mbp loss of one allele. Since, it is common practice to summarise mutations occurring on genes, the `mutation_key` is defined here as `SYMBOL-genotype`. This means that when plotting CNAs for one patient, there could be multiple instances of the same CNA reflecting the number of `studyGenes` involved in that CNA. CNAs are not annotated by a variant annotation tool which is why the mutation details, `mutation_det`, is simply `SYMBOL width_of_CNA genotype`. 

```{r echo = FALSE}
cna <- data.frame(chrom = "chrX", 
                   pos = 276323,
                   SYMBOL = c("KDM6A","SMC1A","BCORL1"),
                   ref = "",
                   alt = "",
                   Consequence = "",
                   mutation_key = c("KDM6A-A","SMC1A-A","BCORL1-A"),
                   mutation_det = c("KDM6A 150Mbp A","SMC1A 150Mbp A","BCORL1 150Mbp A"),
                   variant_type=c("CNA","CNA","CNA"))
knitr::kable(cna)
```


## Clones

In `superFreq` clones are collections of SNVs and CNAs that change together over time. Therefore, they won't have a specific notation apart from identifiying how much a clone changes over time (using an estimate of `clonality`, similar to `VAF`) and how many events are involved in each clone. `varikondo` will be updated so that it will be possible to extract the genes involved in every clones as compyted by `superFreq`. 

Within every patient there will be a finite number of clones identified (3 in the example below) as sumamrised by `mutation_key`. `mutation_det` reports how many `anchors` (events) are in each clone identified. 

```{r echo = FALSE}
clone <- data.frame(PID = c("P1","P1","P1"),
  chrom = "", 
                   pos = "",
                   SYMBOL = "",
                   ref = "",
                   alt = "",
                   mutation_key = c("1","2","3"),
                   mutation_det = c("clone (4 anchors)","clone (10 anchors)","clone (7 anchors)"),
                   variant_type=c("clones","clones","clones"))
knitr::kable(clone)
```


## INDELs reported by VarDict
  
  - `chrom`, `pos`, `SYMBOL`, `ref`, `alt`, `mutation_key` are the same as for `SNVs`.
  - `mutation_det`: details of the mutation defined as `SYMBOL-Consequence`. If the `Consequence` from a variant annotation tool is not available then this can be for example the exon where the variant occurs. In the example below `Consequence` was defined as `ITD` which stands for `Internal Tandem Duplication` which specifies the type of INDEL occurring in the FLT3 gene. 

```{r echo = FALSE}
indel <- data.frame(chrom = "chr13", 
                   pos = 764739898,
                   SYMBOL = "FLT3",
                   ref = "",
                   alt = "GATGATGAT",
                   mutation_key = "chr13-764739898- -GATGATGAT",
                   Consequence = "ITD exon13",
                   mutation_det = "FLT3-ITD exon13",
                   variant_type = "INDEL")
knitr::kable(indel)
```








